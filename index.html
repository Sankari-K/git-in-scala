<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="None" />
      <link rel="shortcut icon" href="img/favicon.ico" />
    <title>Git</title>
    <link rel="stylesheet" href="css/theme.css" />
    <link rel="stylesheet" href="css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Welcome to my implementation of git";
        var mkdocs_page_input_path = "index.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="." class="icon icon-home"> Git
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Welcome to my implementation of git</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#commands-implemented">Commands implemented:</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#project-layout">Project layout</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#packages">Packages</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#data-structures">Data Structures</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#objects">Objects</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#an-executable">An executable</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#testing">Testing</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#creating-repositories-init">Creating repositories: init</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#note">Note</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#adding-files-to-the-staging-area-add">Adding files to the staging area: add</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#saving-changes-to-history-commit">Saving changes to history: commit</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#changes-to-data-structures">Changes to data structures</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rewriting-a-commit-amend">Rewriting a commit: amend</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#rewriting-just-the-commit-message-amend-message">Rewriting just the commit message: amend-message</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#adding-more-staged-files-to-the-last-commit-amend-commit">Adding more staged files to the last commit: amend--commit</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#keeping-commits-clean-squash">Keeping commits clean: squash</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#checking-the-state-of-the-repository-status">Checking the state of the repository: status</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#changes-to-be-committed">Changes to be committed</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#changes-not-staged-for-commit">Changes not staged for commit</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#untracked-files">Untracked files</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#reading-commit-history-log">Reading commit history: log</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#restoring-working-tree-files-restore">Restoring working tree files: restore</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#subcommand-restore-staged">Subcommand: restore--staged</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#restoring-working-tree-files-to-a-hash-checkout">Restoring working tree files to a hash: checkout</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#branching-operations">Branching operations</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#creating-a-branch-create-branch">Creating a branch: create branch</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-and-switching-to-a-branch-checkout-branch">Creating and switching to a branch: checkout branch</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#switching-branches-switch-branch">Switching branches: switch branch</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#renaming-a-branch-rename-branch">Renaming a branch: rename branch</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#rename-current-branch">Rename current branch</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#delete-a-branch">Delete a branch</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#delete-inactive-branches">Delete inactive branches</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#show-inactive-branches">Show inactive branches</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#current-branch-show-current">Current branch: show-current</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#all-branches-show-all">All branches: show-all</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#removing-files-rm">Removing files: rm</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#setting-up-repository-constants-config">Setting up repository constants: config</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ignore-files">Ignore files</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#finding-file-diffs">Finding file diffs</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#using-longest-common-subsequence-for-diffing">Using Longest Common Subsequence for diffing</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#how-lcs-works">How LCS works</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#how-diffing-is-done-with-lcs-information">How diffing is done with LCS information</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#differences-bw-the-working-tree-and-the-staging-area">Differences b/w the working tree and the staging area</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#differences-bw-the-staging-area-and-the-latest-commit">Differences b/w the staging area and the latest commit</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#if-nothing-works-pls-work">If nothing works: pls-work</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#to-do">To do</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href=".">Git</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Welcome to my implementation of git</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="welcome-to-my-implementation-of-git">Welcome to my implementation of git</h1>
<p>I've been using Git for quite some time, and I thought it would be fun to gain a deeper understanding of how it works by attempting to rebuild it based on my interpretation of its functionality.</p>
<h2 id="introduction">Introduction</h2>
<p>This project is a personal implementation of Git, the popular version control system. It’s written in Scala and aims to provide similar functionality to Git while exploring the underlying principles of how version control systems work.</p>
<h3 id="commands-implemented">Commands implemented:</h3>
<ul>
<li><code>init &lt;directory&gt;</code> - Creates a new git repository. <a href="https://git-scm.com/docs/git-init">(git man page)</a></li>
<li><code>add &lt;files&gt;</code> - Adds a file to the staging area. <a href="https://git-scm.com/docs/git-add">(git man page)</a></li>
<li><code>commit &lt;message&gt;</code> - Record changes to the repository. <a href="https://git-scm.com/docs/git-commit">(git man page)</a></li>
<li><code>amend--message</code> - Changes commmit message of latest commit <a href="https://git-scm.com/book/en/v2/Git-Basics-Undoing-Things">similar to (git man page)</a></li>
<li><code>amend--commit</code> - Add additional staged changes to the commit <a href="https://git-scm.com/book/en/v2/Git-Basics-Undoing-Things">similar to (git man page)</a></li>
<li><code>squash</code> - Merges multiple commits into one to keep the repo clean <a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History.html#_rewriting_history">(git man page)</a></li>
<li><code>status</code> - Show the working tree status of the repository. <a href="https://git-scm.com/docs/git-status">(git man page)</a></li>
<li><code>log</code> - Show all commits made. <a href="https://git-scm.com/docs/git-log">(git man page)</a></li>
<li><code>restore &lt;files&gt;</code> - Restore working tree files. <a href="https://git-scm.com/docs/git-restore">(git man page)</a></li>
<li><code>restore--staged &lt;files&gt;</code> - Restore content in the index. <a href="https://git-scm.com/docs/git-restore">(git man page)</a></li>
<li><code>checkout &lt;hash&gt;</code> - Restore working tree files to the given hash. <a href="https://git-scm.com/docs/git-checkout">(git man page)</a></li>
<li><code>rm &lt;files&gt;</code> - Remove files from the worktree and index. <a href="https://git-scm.com/docs/git-rm">(git man page)</a></li>
<li><code>config &lt;key&gt; &lt;value&gt;</code> - Sets the <code>key</code>'s value to be equal to <code>value</code> in git's config file.
<br></li>
</ul>
<p>Please refer to <a href="https://git-scm.com/docs/user-manual.html#manipulating-branches">this</a> manual for branching commands</p>
<ul>
<li><code>create branch &lt;branch name&gt;</code> - Creates a new branch with the name given, doesn't switch to the new branch.</li>
<li><code>checkout branch &lt;branch name&gt;</code> - Creates a new branch and switches to it.</li>
<li><code>switch branch &lt;branch name&gt;</code> - Switches to an existing branch.</li>
<li><code>rename branch &lt;new branch name&gt;</code> - Renames current branch to new branch</li>
<li><code>rename branch &lt;old branch name&gt; &lt;new branch name&gt;</code> - Renames a given branch to something else.</li>
<li><code>delete branch &lt;branch name&gt;</code> - Deletes a given branch</li>
<li><code>delete branch since &lt;days&gt; days</code> - Deletes branches that have been inactive for the past <code>days</code> days (with the exception of the current branch)</li>
<li><code>show branch since &lt;days&gt; days</code> - Shows branches that have been inactive for the past <code>days</code> days (with the exception of the current branch)</li>
<li><code>branch show-current</code> - Shows the current branch that the repo is on.</li>
<li><code>branch show-all</code> - Shows all branches created.</li>
<li><code>diff &lt;file&gt;</code> - Shows the diff between the working directory and <code>INDEX</code> for a particular file. <a href="https://git-scm.com/docs/git-diff">(git man page)</a></li>
<li><code>diff--staged &lt;file&gt;</code> - Shows the diff between the <code>INDEX</code> and the latest commit for a particular file. <a href="https://git-scm.com/docs/git-diff">(git man page)</a></li>
<li><code>pls-work</code> - A desperate plea to the version control gods. Sometimes, you just need a little extra luck.</li>
</ul>
<h2 id="project-layout">Project layout</h2>
<h3 id="packages">Packages</h3>
<p>The <code>main.scala</code> file has code to parse the command line arguments and call the respective "bridge functions" located in separate scala files. There are three types of packages:</p>
<pre><code>package gitcommands # has code for individual git commands
package datastructs # has code for the data structures I've made
package fileops # has helper functions related to file operations
</code></pre>
<p>A wegit repo looks like this:</p>
<pre><code>.wegit/
    INDEX
    COMMIT
    objs/
        e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  # a blob
        ...       # more blobs
</code></pre>
<p>All file objects are represented by a SHA hash. The contents of the file are compressed and stored in the <code>objs/</code> directory, where the name of the file is its SHA hash.</p>
<h3 id="data-structures">Data Structures</h3>
<p>An INDEX data structure and a COMMIT data structure are used to represent the current state of the repository.</p>
<p>The index looks like a <code>String =&gt; (String, String)</code> map. The key is the path of the file, and the tuple represents the <code>old</code> and <code>new</code> SHA hashes of the file. The <code>oldhash</code> is the state of the file from the latest commit (or <code>null</code> if it didn't exist) and the <code>newhash</code> is the state of the file from the latest <code>git add</code> operation.</p>
<p>For example, an index file would look like this:</p>
<pre><code class="language-plaintext">    1.txt:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855:2860d7deca71859f9fae69da862b3934b772f24d23137f326a030bf042dc8d7d
    2.txt:0051eb1be2439f3db88107f1c8643256d331f3078dc5d51b7c40acfeb03c88b1:0051eb1be2439f3db88107f1c8643256d331f3078dc5d51b7c40acfeb03c88b1
    3.txt:null:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    egfolder\4.txt:null:e4ec861d34ab491b5b8538ee693c70ccda97e2ac861b8719b0b1d2ffdfe69cd7
</code></pre>
<p>A commit is just a snapshot of an index file with an additional commit message, author name and email, a timestamp of the commit, and a unique commit hash that is generated. It would look like this:</p>
<pre><code class="language-plaintext">    [da563b40a3e49923b50a173b0cc73c40627a0430]
    Second commit
    sankari
    sankarikarthik03@gmail.com
    sunday march 9 20:47:35 2025 +0530
    1.txt=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855,2860d7deca71859f9fae69da862b3934b772f24d23137f326a030bf042dc8d7d
    2.txt=0051eb1be2439f3db88107f1c8643256d331f3078dc5d51b7c40acfeb03c88b1,0051eb1be2439f3db88107f1c8643256d331f3078dc5d51b7c40acfeb03c88b1
    3.txt=null,e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    egfolder\4.txt=null,e4ec861d34ab491b5b8538ee693c70ccda97e2ac861b8719b0b1d2ffdfe69cd7

    [8baedf145e0717cf216d30f5bb75afc643326ab5]
    First commit
    sankari
    sankarikarthik03@gmail.com
    sunday march 9 20:42:27 2025 +0530
    2.txt=null,0051eb1be2439f3db88107f1c8643256d331f3078dc5d51b7c40acfeb03c88b1
    1.txt=null,e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</code></pre>
<h3 id="objects">Objects</h3>
<p>All files tracked by git must have a corresponding file in the <code>.wegit/objs</code> directory. As mentioned earlier, all file objects are represented by a SHA hash. The contents of the file are compressed (using zlib) and stored in the <code>objs/</code> directory, where the name of the file is its SHA hash.</p>
<h2 id="usage">Usage</h2>
<h3 id="an-executable">An executable</h3>
<p>A <a href="https://en.wikipedia.org/wiki/JAR_(file_format)">jar file</a> can be created using the scala build tool, called <code>sbt</code>. </p>
<h3 id="testing">Testing</h3>
<p>For testing, running <code>scala run *.scala</code> in the same directory as the program should print out the usage.</p>
<h2 id="creating-repositories-init">Creating repositories: init</h2>
<p>There are two ways this command can be executed - by leaving it blank (<code>scala run *.scala -- init</code>) in which case it creates a new git repo in the same directory, or by explicitly mentioning the directory where the git repo needs to be created.</p>
<p>This command first checks if the given directory is already an existing repo (by checking for the existence of a <code>.wegit</code> folder). If it is, an error message is printed out. Otherwise, a <code>.wegit</code> directory and a nested <code>objs/</code> folder is created.</p>
<h3 id="note">Note</h3>
<p>In all the following commands, a check is done to make sure the directory is a git repository before executing the command. If it isn't an existing repo, an appropriate error message is printed out.</p>
<h2 id="adding-files-to-the-staging-area-add">Adding files to the staging area: add</h2>
<p>This command can take multiple files as its argument. After getting "added", their modifications are tracked by git. </p>
<p>This is done in code by iterating through all files in the directory and updating the file's <code>newhash</code> by calculating the hash of its current contents. The <code>oldhash</code> remains the same. If a file didn't exist earlier, the <code>oldhash</code> is <code>null</code>. The hash generated for an empty file is a different, non-null value.</p>
<p>This takes care of a few things:</p>
<ul>
<li>If a file is added but has no modifications, no changes are made in the <code>INDEX</code> file.</li>
<li>If there are multiple edit-add cycles on the same file (without any <code>commit</code>s), we only care about the latest content of the file - not the contents in the intermediate stages.</li>
<li>If a file is deleted, we can track that change nicely by just changing the <code>newhash</code> to <code>null</code>.</li>
<li>Similarly, a new file being staged can be detected by checking if the <code>oldhash</code> is <code>null</code>.</li>
</ul>
<p>After the INDEX file is updated, the file's compressed contents are stored in the <code>objs/</code> folder with the name being its <code>SHA</code> hash.</p>
<h2 id="saving-changes-to-history-commit">Saving changes to history: commit</h2>
<p>A <code>commit</code> is expected to take a snapshot of the current <code>INDEX</code> file and store it along with more useful information (like, a message). If an <code>INDEX</code> file doesn't exist already, the operation is terminated. Otherwise, a commit hash is generated which takes the <code>INDEX</code> contents (yes, all of it) as opposed to just the file names or any other variation as its argument. </p>
<ul>
<li>So, if there are any changes to the <code>INDEX</code>, that guarantees a different commit hash. </li>
<li>No changes to the <code>INDEX</code> would lead to the commit hash being the same. This is a nice way to check for changes in the <code>INDEX</code>.</li>
</ul>
<h3 id="changes-to-data-structures">Changes to data structures</h3>
<p>This operation does two things:</p>
<ul>
<li>Makes a commit with the generated commit hash (essentially copies the current contents in the <code>INDEX</code> file and makes an entry in the <code>COMMIT</code> file).</li>
<li>Iterates over the <code>INDEX</code> and updates it - both the <code>oldhash</code> and the <code>newhash</code> are populated with the <code>newhash</code> value. Any file with <code>newhash</code> as <code>null</code> is a deleted file, so it gets removed from the <code>INDEX</code>.</li>
</ul>
<hr />
<p><strong>NOTE</strong></p>
<blockquote>
<p>📣 "No changes to the <code>INDEX</code> would lead to the commit hash being the same. This is a nice way to check for changes in the <code>INDEX</code>."
   This is true in principle. However, consider this case:</p>
</blockquote>
<pre><code class="language-python">    scala run ./*.scala -- add 1.txt
    scala run ./*.scala -- commit &quot;Added file&quot;
    scala run ./*.scala -- commit &quot;Is this possible&quot;
</code></pre>
<blockquote>
<p>Ideally, the second commit should not be possible. But the <code>commit</code> operation updates the <code>oldhash</code> to be the <code>newhash</code>, so the <code>INDEX</code> technically changes and a commit would be possible.</p>
<p>Similarly in this situation:</p>
</blockquote>
<pre><code class="language-python">    scala run ./*.scala -- rm 1.txt
    scala run ./*.scala -- commit &quot;Deleted file&quot;
    scala run ./*.scala -- commit &quot;Is this possible&quot;
</code></pre>
<blockquote>
<p>These cases are taken care of by explicitly checking the <code>INDEX</code> for changes before a commit, and not just the hash of the <code>INDEX</code> contents.</p>
</blockquote>
<hr />
<h2 id="rewriting-a-commit-amend">Rewriting a commit: amend</h2>
<h3 id="rewriting-just-the-commit-message-amend-message">Rewriting just the commit message: amend-message</h3>
<p>To just change the commit message of the latest commit, this command can be used. This doesn't change the commit hash, but changes the timestamp of the commit.</p>
<h3 id="adding-more-staged-files-to-the-last-commit-amend-commit">Adding more staged files to the last commit: amend--commit</h3>
<p>This command can be used if a commit is done too early and one possibly forgets to add some files. This is done by fetching the latest commit,
iterating over the current <code>INDEX</code>.</p>
<pre><code class="language-plaintext">    for all (file, (oldhash, newhash)) in index:
        lastoldhash, lastnewhash = previousIndex
        index.update(file, (lastoldhash, newhash))
</code></pre>
<p>One case to be considered - if the file was deleted as part of the previous commit, there won't be an entry in the current <code>INDEX</code> - in that case, the old index must be iterated through to update the <code>INDEX</code>.</p>
<pre><code class="language-plaintext">    for all (file, (lastoldhash, lastnewhash)) in previousIndex:
        if file not in index:
            index.update(file, (lastoldhash, lastnewhash))
</code></pre>
<p>The latest commit is removed, and a new commit hash is generated based on the updated <code>INDEX</code>. Depending on whether a message was provided or not, the given message or the previous message is taken to create a commit. After the commit, the <code>INDEX</code> is updated like the commit section earlier.</p>
<h2 id="keeping-commits-clean-squash">Keeping commits clean: squash</h2>
<p>Multiple commits can be merged into one to keep the repo history clean and succint. This is done by taking the last <code>n</code> commits (<code>n</code> given by the user) and merging two at a time much like the previous commit and the <code>INDEX</code> was merged for <code>amend-commit</code>. The only difference here is that:</p>
<ul>
<li>No changes are actually made to the current <code>INDEX</code></li>
<li>All the <code>n</code> commits are deleted, and replaced by a new commit with a new commit hash and message.</li>
</ul>
<p>If <code>n</code> is greater than the number of commits present in the repository, an appropriate error message is shown. </p>
<h2 id="checking-the-state-of-the-repository-status">Checking the state of the repository: status</h2>
<h3 id="changes-to-be-committed">Changes to be committed</h3>
<p>The <code>INDEX</code> is iterated over and - </p>
<ul>
<li>New files are found by making sure <code>oldhash</code> is <code>null</code> (file didn't exist earlier) and <code>newhash</code> isn't <code>null</code> (file was deleted after staging it).</li>
<li>Modifed files are found by making sure <code>oldhash</code> and <code>newhash</code> aren't <code>null</code>, and <code>oldhash</code> is different from <code>newhash</code>.</li>
<li>Deleted files are found by making sure <code>newhash</code> is <code>null</code>.</li>
</ul>
<h3 id="changes-not-staged-for-commit">Changes not staged for commit</h3>
<p>All files in the <code>INDEX</code> are iterated over - </p>
<ul>
<li>
<p>If the file exists, and <code>newhash</code> isn't <code>null</code> (if <code>newhash</code> is null, that means the deletion of the file is staged) the current contents of the file are found, and the hash is computed. If that isn't equal to the <code>newhash</code> present in the <code>INDEX</code> for that file, there are untracked modifications.</p>
</li>
<li>
<p>If the file doesn't exist and if <code>newhash</code> is <code>null</code>, that means it was deleted outside of <code>wegit</code> - so this is an unstaged deletion (the only place where this case is being considered, please refer to known decisions made).</p>
</li>
</ul>
<h3 id="untracked-files">Untracked files</h3>
<p>All files in the repo are iterated over -</p>
<ul>
<li>If the file is not present in the <code>INDEX</code>, it is an untracked file.</li>
</ul>
<p>Implementing <code>git status</code> was quite straightforward thanks to thorough brainstorming and choosing the right modules and data structures. This taught me the importance of spending time upfront on basic architecture.</p>
<h2 id="reading-commit-history-log">Reading commit history: log</h2>
<p>This just iterates through all <code>commit</code>s made and prints out each one's hash and message.</p>
<h2 id="restoring-working-tree-files-restore">Restoring working tree files: restore</h2>
<p>This command deletes working tree changes and restores back the previously staged changes. This is done by getting the <code>newhash</code> from the <code>INDEX</code> for the given file (latest version that was added), and replacing the current contents of the file with the contents pointed to in the <code>objs/</code> directory by the <code>newhash</code>.</p>
<h3 id="subcommand-restore-staged">Subcommand: restore--staged</h3>
<p>This command unstages local changes by removing the specified file(s) from the <code>INDEX</code>.</p>
<h2 id="restoring-working-tree-files-to-a-hash-checkout">Restoring working tree files to a hash: checkout</h2>
<p>Before the command is run, it makes sure there are no local changes that haven't been committed. Unmodified changes are checked by:</p>
<ul>
<li>Checking the diff between the <code>INDEX</code> and current state of files</li>
<li>Checking the diff in <code>INDEX</code> to check for uncommitted changes.</li>
</ul>
<p>Then, the current <code>INDEX</code> is modified to look like the particular commit referenced by the hash given. If the <code>commithash</code> doesn't match any commit, the checkout is aborted. </p>
<h2 id="branching-operations">Branching operations</h2>
<p>Branches are implemented by adding folders inside <code>.wegit</code> and inside of those folders, there will be separate <code>INDEX</code> and <code>COMMIT</code> files (this means there will be multiple staging areas).</p>
<p>The current branch is stored in a file called <code>HEAD-NAME</code> inside the <code>.wegit/</code> directory.</p>
<pre><code class="language-plaintext">.wegit/
    main/
        INDEX
        COMMIT
    feature/
        INDEX
        COMMIT
    objs/
        e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  # a blob
        ...       # more blobs
</code></pre>
<h3 id="creating-a-branch-create-branch">Creating a branch: create branch</h3>
<p>This is done by creating a directory for this branch inside <code>.wegit/</code>. If such a branch exists already, or if the branch name given is invalid (<code>objs</code> or <code>config</code>, for example), the operation is terminated with an appropriate error message.</p>
<p>Next, the new <code>INDEX</code> and <code>COMMIT</code> files are created. This is done by copying over the contents from the current branch this command is run from. This command does not switch to the newly created branch.</p>
<h3 id="creating-and-switching-to-a-branch-checkout-branch">Creating and switching to a branch: checkout branch</h3>
<p>This pretty much does what <code>create branch</code> does, except it also updates <code>HEAD-NAME</code>. </p>
<hr />
<p><strong>NOTE</strong></p>
<blockquote>
<p>📣 Neither of these operations require a check of any unstaged/uncommitted files, since a new branch is created.</p>
</blockquote>
<hr />
<h3 id="switching-branches-switch-branch">Switching branches: switch branch</h3>
<p>First things first, it makes sure there are no unstaged changes. Each branch can have its own distinct staging area, but unstaged changes are present only in the working tree. This also means that if there are untracked files in the current branch, moving to another branch (where it is tracked and has different contents in it) will get overwritten. If there are unstaged changes in tracked files, the operation is aborted.</p>
<p>Then, validation is done to make sure such a branch exists and the user isn't already on that branch. </p>
<p>Objects in the current index are removed (the files are deleted), the <code>HEAD-NAME</code> file is made to point to the new branch. Then, objects are added to look like the new branch's <code>INDEX</code>.</p>
<h3 id="renaming-a-branch-rename-branch">Renaming a branch: rename branch</h3>
<p>If two arguments are given, this command renames the <code>oldbranch</code> to <code>newbranch</code>. Three pre-checks are done:</p>
<ul>
<li><code>newbranch</code> isn't already a branch</li>
<li><code>newbranch</code> isn't invalid (<code>objs</code> or <code>config</code>, for example)</li>
<li><code>oldbranch</code> is already a branch</li>
</ul>
<p>Then, the <code>oldbranch/</code> directory is renamed to <code>newbranch/</code>.</p>
<h4 id="rename-current-branch">Rename current branch</h4>
<p>If only one argument is given or if the <code>oldbranch</code> happens to be the current branch, this (current) branch is renamed to the given <code>newbranch</code>.</p>
<p>This additionally changes <code>HEAD-NAME</code> to the the new branch name.</p>
<h3 id="delete-a-branch">Delete a branch</h3>
<p>Given a branch name, this command deletes the directory <code>./wegit/branchname</code>. Two basic pre-checks are done for <code>branchname</code>:</p>
<ul>
<li>the branch can't be the current branch</li>
<li>the branch must exist</li>
</ul>
<h3 id="delete-inactive-branches">Delete inactive branches</h3>
<p>This is done by iterating over all branches that have atleast one commit (with the exception of the current branch since it can't be deleted while on it anyway), finding the latest commit's timestamp and checking how long it has been since that commit was made. If that amount is greater than the amount of time given by the user, the branch is deleted.</p>
<h3 id="show-inactive-branches">Show inactive branches</h3>
<p>This does the same thing as mentioned above, except it only prints out those branches, doesn't delete them. This command can be used to check which branches will get deleted before using the previous command.</p>
<h3 id="current-branch-show-current">Current branch: show-current</h3>
<p>This shows the contents in <code>HEAD-NAME</code>.</p>
<h3 id="all-branches-show-all">All branches: show-all</h3>
<p>This shows all branches in the repo, with markers for what the current branch is. This is done by iterating over all folders in the <code>.wegit/</code> directory (and not considering the <code>objs/</code> folder). </p>
<h2 id="removing-files-rm">Removing files: rm</h2>
<p>This command deletes the specified file and updates that information in the <code>INDEX</code> =&gt; it stages the "deletion".
That is done by updating the <code>newhash</code> for that file to <code>null</code> and deleting the file from the file system.</p>
<p>If there are staged changes in the <code>INDEX</code> for that file, the operation is aborted.</p>
<h2 id="setting-up-repository-constants-config">Setting up repository constants: config</h2>
<p>This is used to save global variables about the repo, such as the user's name and email (which are used for commit operations).</p>
<h2 id="ignore-files">Ignore files</h2>
<p>To ignore a file, a <code>.ignore</code> file can be created in the root directory. A file can't be <code>add</code>ed if it is in the <code>.ignore</code> file.</p>
<h2 id="finding-file-diffs">Finding file diffs</h2>
<p>A line by line diffing algorithm won't work since even if one line is removed, all following lines appear as changed.</p>
<h3 id="using-longest-common-subsequence-for-diffing">Using Longest Common Subsequence for diffing</h3>
<p>To fix this issue, longest common subsequence is used. The goal is to compare two lists of strings (original and modified versions of a file) and output the differences in a meaningful way.</p>
<p>The LCS is the longest sequence of lines that appears in both files in order, but not necessarily consecutively. </p>
<h4 id="how-lcs-works">How LCS works</h4>
<p>Given two lists of strings <code>a</code> (of length <code>i</code>) and <code>b</code> (of length <code>j</code>) - </p>
<ol>
<li>Create a 2D dp table where <code>dp(i)(j)</code> stores the length of LCS for <code>a[0..i - 1]</code> and <code>b[0..j - 1]</code>.</li>
<li>Fill the dp table using dynammic programming:<ul>
<li>If <code>a[i - 1]</code> == <code>b[j - 1]</code>, then the LCS extends:
    <code>dp(i, j) = dp(i - 1, j - 1) + 1</code></li>
<li>Otherwise, take the maximum LCS length by skipping either <code>a[i - 1]</code> or <code>b[j - 1]</code>: <code>dp(i, j) = max(dp(i − 1, j), dp(i, j − 1))</code></li>
</ul>
</li>
<li>Backtrack to extract the LCS indices:<ul>
<li>Start from the bottom-right of the table `(i = a.length, j = b.length)</li>
<li>If <code>a[i - 1]</code> == <code>b[j - 1]</code>, it is part of LCS → store <code>(i - 1, j - 1)</code></li>
<li>Otherwise, move in the direction of the larger LCS value</li>
</ul>
</li>
</ol>
<p>This function returns a set of <code>(i, j)</code> indices, which represents matching lines in both files.</p>
<h4 id="how-diffing-is-done-with-lcs-information">How diffing is done with LCS information</h4>
<ol>
<li>
<p>Two pointers are initialized:</p>
<ul>
<li><code>i = 0</code> (points to current line in list of lines <code>a</code>)</li>
<li><code>j = 0</code> (points to current line in list of lines <code>b</code>)</li>
</ul>
</li>
<li>
<p>Iterate through both files until all lines are processed:</p>
<ul>
<li>The lines match (<code>a(i) == b(j)</code>): Output the line normally, since it is unchanged. Move both pointers forward.</li>
<li>A line was deleted (exists in <code>a</code> but not in the set returned by LCS): Print in red (- line), indicating it was removed. Move just the <code>i</code> pointer forward.</li>
<li>A line was added (exists in <code>b</code> but not in the set returned by LCS): Print in green (+ line), indicating it was added. Move just the <code>j</code> pointer forward.</li>
<li>A line was modified (exists in both, but changed): 
Print the original in red (- line).
Print the new version in green (+ line).
Move both pointers forward.</li>
</ul>
</li>
</ol>
<h3 id="differences-bw-the-working-tree-and-the-staging-area">Differences b/w the working tree and the staging area</h3>
<p>This finds the difference between the working tree(+) with respect to the index(-). If the file doesn't exist in the filesystem, it prints out an error message.</p>
<p>The <code>INDEX</code> is initialized and the indexed content is found by reading the compressed <code>newhash</code> object from the <code>objs/</code> directory. Since the file definitely exists, <code>newhash</code> will definitely not be <code>null</code>.</p>
<p>The working tree's content is found by just reading the file in the repo.</p>
<p>The diff between these two is found with the algorithm described above.</p>
<h3 id="differences-bw-the-staging-area-and-the-latest-commit">Differences b/w the staging area and the latest commit</h3>
<p>This finds the difference between the index(+) with respect to the latest commit(-). Here, there is no need to check if the file exists in the filesystem since that info is never used anyway.</p>
<p>The <code>INDEX</code> is initialized and the indexed content is found by reading the compressed <code>newhash</code> and <code>oldhash</code> objects from the <code>objs/</code> directory. Since there's no guarantee that the file exists in the working directory (a git rm could have been done), <code>newhash</code> needs to be non-null and that's checked. Also, there's no guarantee that this file was part of a commit already so <code>oldhash</code> needs to be non-null as well.</p>
<p>If either hashes are <code>null</code>, the respective file contents are taken to be empty. </p>
<p>No brownie points for guessing how the diff between these two is found 🍪</p>
<h2 id="if-nothing-works-pls-work">If nothing works: pls-work</h2>
<p>(self-explanatory)</p>
<hr />
<p><strong>📣 NOTE: SOME KNOWN DECISIONS TAKEN</strong></p>
<p>List of things that were researched, but have been decided as out of scope:</p>
<ol>
<li>
<p>Git ideally has to check for when files are deleted outside of git. For now, an assumption is made that files are only deleted with the <code>rm</code> command inside of <code>wegit</code>. This also means that any deletion is always a staged change, and never an unstaged change. (I've coded up logic to check for unstaged deletions in status alone, but not anywhere else)</p>
</li>
<li>
<p>Ideally, git asks to <code>stash</code> changes when switching branches when there are uncommitted/unstaged changes - this depends on whether/how the working tree must be changed. If it is "clean", switching can be done without stashing or committing. Long story short, there are rules set in place with a lot of corner cases. If interested, this is a good place to start to go down a rabbit hole: <a href="https://stackoverflow.com/a/22055552/14719340">Checkout another branch when there are uncommitted changes on the current branch</a></p>
</li>
</ol>
<hr />
<h2 id="to-do">To do</h2>
<p>There are quite a few things I'd like to build upon. This section keeps track of ideas, improvements, and features I’d like to implement in the future (or, as I like to call it, a staging area for future ideas :P).</p>
<ul>
<li>Make an executable</li>
<li>Make sure executable can be run from anywhere</li>
<li>
<p>Add must be able to take in </p>
<ul>
<li>current directory ("." or no params) </li>
<li>any directory (relative or absolute)</li>
<li>multiple files <strong>[DONE]</strong></li>
</ul>
</li>
<li>
<p>In general, wegit must run inside any (nested) part of the repo</p>
</li>
<li>Implement .gitignore <strong>[DONE]</strong></li>
<li>Move the prints to a separate module (a log/message/error handler)</li>
<li>Implement git delete (and make sure status captures it) <strong>[DONE]</strong></li>
<li>Add parameters like author, timestamp for a git commit <strong>[DONE]</strong></li>
<li>
<p>Go through modules made and delete unnecessary helper functions <strong>[DONE]</strong></p>
</li>
<li>
<p>Implement all of git checkout</p>
<ul>
<li>Create a <code>HEAD</code> file (to implement the logic for "detached head")</li>
</ul>
</li>
<li>
<p>Create a git commit--amend command <strong>[DONE]</strong></p>
</li>
<li>Create docstrings and pull 'em in for the help/usage command</li>
<li>Debug this situation - a commit has been made, but no changes in the <code>INDEX</code>. Currently, the commit message and hash are created (but aren't being modified in the <code>INDEX</code>). <strong>[DONE]</strong></li>
<li>Optimize the "changes not staged for commit" functionality in git status. There's no need to iterate over all files in the repository. <strong>[DONE]</strong></li>
<li>Make sure deletion/undeletion works fine for all operations (like restore--staged and adding a deleted file)</li>
<li>If (big if) I decide to implement unstaged deletion, get <code>git ls-files --deleted</code> to work</li>
<li>Ability to visualize commit tree across branches</li>
<li>Implement nesting of files and ability to run commands from anywhere inside the repo</li>
</ul>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="js/jquery-3.6.0.min.js"></script>
    <script>var base_url = ".";</script>
    <script src="js/theme_extra.js"></script>
    <script src="js/theme.js"></script>
      <script src="search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>

<!--
MkDocs version : 1.6.1
Build Date UTC : 2025-03-22 10:10:07.571595+00:00
-->
